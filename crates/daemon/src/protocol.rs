//! DataCraft Protocol Handler
//!
//! Integrates DataCraft with libp2p swarm, handles DHT operations and incoming transfer streams.

use std::collections::HashMap;
use std::sync::Arc;

use datacraft_core::{ContentId, ChunkManifest, TRANSFER_PROTOCOL};
use datacraft_routing::ContentRouter;
use datacraft_store::FsStore;
use datacraft_transfer::{decode_shard_request, REQUEST_HEADER_SIZE};
use craftec_network::{CraftBehaviour, behaviour::CraftBehaviourEvent};
use libp2p::kad;
use libp2p::swarm::SwarmEvent;
use libp2p_stream::IncomingStreams;
use tokio::sync::{mpsc, Mutex};
use tracing::{debug, error, warn};

/// Events generated by the DataCraft protocol handler.
#[derive(Debug)]
pub enum DataCraftEvent {
    /// DHT provider query completed.
    ProvidersResolved {
        content_id: ContentId,
        providers: Vec<libp2p::PeerId>,
    },
    /// DHT manifest record retrieved.
    ManifestRetrieved {
        content_id: ContentId,
        manifest: ChunkManifest,
    },
    /// DHT operation failed.
    DhtError {
        content_id: ContentId,
        error: String,
    },
}

/// DataCraft protocol handler for registration on shared libp2p swarm.
pub struct DataCraftProtocol {
    /// Local content store.
    store: Arc<Mutex<FsStore>>,
    /// Event sender to the daemon.
    event_tx: mpsc::UnboundedSender<DataCraftEvent>,
    /// Pending DHT queries waiting for completion.
    pending_queries: Arc<Mutex<HashMap<kad::QueryId, PendingQuery>>>,
}

/// Tracks what we're waiting for from a DHT query.
#[derive(Debug)]
enum PendingQuery {
    ProvidersLookup { content_id: ContentId },
    ManifestLookup { content_id: ContentId },
}

impl DataCraftProtocol {
    /// Create a new DataCraft protocol handler.
    pub fn new(
        store: Arc<Mutex<FsStore>>,
        event_tx: mpsc::UnboundedSender<DataCraftEvent>,
    ) -> Self {
        Self {
            store,
            event_tx,
            pending_queries: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    /// Register this protocol with the shared libp2p swarm.
    pub fn register(
        &self,
        swarm: &mut craftec_network::CraftSwarm,
    ) -> Result<IncomingStreams, Box<dyn std::error::Error>> {
        debug!("Registering DataCraft transfer protocol: {}", TRANSFER_PROTOCOL);
        
        // Get stream control from the behavior
        let mut control = swarm.behaviour().stream_control();
        
        // Accept incoming streams for our protocol
        let incoming_streams = control.accept(libp2p::StreamProtocol::new(TRANSFER_PROTOCOL))?;
        
        Ok(incoming_streams)
    }

    /// Announce this node as a provider for the given content ID.
    pub async fn announce_provider(
        &self,
        behaviour: &mut CraftBehaviour,
        content_id: &ContentId,
    ) -> Result<(), Box<dyn std::error::Error>> {
        debug!("Announcing as provider for {}", content_id);
        ContentRouter::announce(behaviour, content_id)?;
        Ok(())
    }

    /// Publish a manifest to the DHT.
    pub async fn publish_manifest(
        &self,
        behaviour: &mut CraftBehaviour,
        manifest: &ChunkManifest,
        local_peer_id: &libp2p::PeerId,
    ) -> Result<(), Box<dyn std::error::Error>> {
        debug!("Publishing manifest for {} to DHT", manifest.content_id);
        ContentRouter::publish_manifest(behaviour, manifest, local_peer_id)?;
        Ok(())
    }

    /// Resolve providers for a content ID via DHT.
    pub async fn resolve_providers(
        &self,
        behaviour: &mut CraftBehaviour,
        content_id: &ContentId,
    ) -> Result<(), Box<dyn std::error::Error>> {
        debug!("Resolving providers for {}", content_id);
        let query_id = ContentRouter::resolve(behaviour, content_id);
        
        // Track this query so we can match the response
        let mut queries = self.pending_queries.lock().await;
        queries.insert(query_id, PendingQuery::ProvidersLookup { 
            content_id: *content_id 
        });
        
        Ok(())
    }

    /// Get a manifest from the DHT.
    pub async fn get_manifest(
        &self,
        behaviour: &mut CraftBehaviour,
        content_id: &ContentId,
    ) -> Result<(), Box<dyn std::error::Error>> {
        debug!("Getting manifest for {}", content_id);
        let query_id = ContentRouter::get_manifest(behaviour, content_id);
        
        // Track this query
        let mut queries = self.pending_queries.lock().await;
        queries.insert(query_id, PendingQuery::ManifestLookup { 
            content_id: *content_id 
        });
        
        Ok(())
    }

    /// Handle libp2p swarm events related to DataCraft.
    pub async fn handle_swarm_event(&self, event: &SwarmEvent<CraftBehaviourEvent>) {
        match event {
            SwarmEvent::Behaviour(CraftBehaviourEvent::Kademlia(kad_event)) => {
                self.handle_kademlia_event(kad_event).await;
            }
            _ => {
                // Other events (connections, etc.) are handled by the main swarm loop
            }
        }
    }

    /// Handle Kademlia DHT events.
    async fn handle_kademlia_event(&self, event: &libp2p::kad::Event) {
        use libp2p::kad::Event;

        match event {
            Event::OutboundQueryProgressed { id, result, .. } => {
                self.handle_query_result(*id, result).await;
            }
            _ => {
                // Other Kademlia events not relevant for DataCraft
            }
        }
    }

    /// Handle the result of a DHT query.
    async fn handle_query_result(
        &self,
        query_id: kad::QueryId,
        result: &kad::QueryResult,
    ) {
        use libp2p::kad::{QueryResult, GetProvidersOk, GetRecordOk};

        let mut queries = self.pending_queries.lock().await;
        let pending = match queries.remove(&query_id) {
            Some(p) => p,
            None => {
                debug!("Received result for unknown query: {:?}", query_id);
                return;
            }
        };

        match (pending, result) {
            (PendingQuery::ProvidersLookup { content_id }, QueryResult::GetProviders(Ok(GetProvidersOk::FoundProviders { providers, .. }))) => {
                debug!("Found {} providers for {}", providers.len(), content_id);
                let provider_peers: Vec<libp2p::PeerId> = providers.iter().cloned().collect();
                
                let event = DataCraftEvent::ProvidersResolved {
                    content_id,
                    providers: provider_peers,
                };
                
                if let Err(e) = self.event_tx.send(event) {
                    error!("Failed to send providers resolved event: {}", e);
                }
            }
            
            (PendingQuery::ManifestLookup { content_id }, QueryResult::GetRecord(Ok(GetRecordOk::FoundRecord(peer_record)))) => {
                debug!("Found manifest record for {}", content_id);
                
                match datacraft_routing::parse_manifest_record(&peer_record.record.value) {
                    Ok(manifest) => {
                        let event = DataCraftEvent::ManifestRetrieved {
                            content_id,
                            manifest,
                        };
                        
                        if let Err(e) = self.event_tx.send(event) {
                            error!("Failed to send manifest retrieved event: {}", e);
                        }
                    }
                    Err(e) => {
                        warn!("Failed to parse manifest record for {}: {}", content_id, e);
                        let event = DataCraftEvent::DhtError {
                            content_id,
                            error: format!("Failed to parse manifest: {}", e),
                        };
                        
                        if let Err(e) = self.event_tx.send(event) {
                            error!("Failed to send DHT error event: {}", e);
                        }
                    }
                }
            }

            (pending, result) => {
                debug!("Query {:?} completed with unhandled result: {:?}", pending, result);
                
                // Extract content_id for error reporting
                let content_id = match pending {
                    PendingQuery::ProvidersLookup { content_id } => content_id,
                    PendingQuery::ManifestLookup { content_id } => content_id,
                };
                
                let error_msg = match result {
                    QueryResult::GetProviders(Err(e)) => format!("Providers lookup failed: {:?}", e),
                    QueryResult::GetRecord(Err(e)) => format!("Record lookup failed: {:?}", e),
                    _ => "Query completed with no results".to_string(),
                };
                
                let event = DataCraftEvent::DhtError {
                    content_id,
                    error: error_msg,
                };
                
                if let Err(e) = self.event_tx.send(event) {
                    error!("Failed to send DHT error event: {}", e);
                }
            }
        }
    }

    /// Handle an incoming transfer stream from a peer.
    pub async fn handle_incoming_stream(&self, mut stream: libp2p::Stream) {
        use futures::{AsyncReadExt, AsyncWriteExt};

        debug!("Handling incoming transfer stream");
        
        // Read the request header
        let mut header = [0u8; REQUEST_HEADER_SIZE];
        if let Err(e) = stream.read_exact(&mut header).await {
            error!("Failed to read request header: {}", e);
            return;
        }

        // Decode the request
        let (content_id, chunk_index, shard_index) = match decode_shard_request(&header) {
            Ok(req) => req,
            Err(e) => {
                error!("Failed to decode shard request: {}", e);
                return;
            }
        };

        debug!(
            "Serving shard request: {} chunk={} shard={}",
            content_id, chunk_index, shard_index
        );

        // Serve the shard from local store - need custom implementation for libp2p::Stream
        let store = self.store.lock().await;
        
        match store.get_shard(&content_id, chunk_index, shard_index) {
            Ok(data) => {
                debug!(
                    "Serving shard {}/{}/{} ({} bytes)",
                    content_id, chunk_index, shard_index, data.len()
                );
                let response = datacraft_transfer::encode_response(datacraft_core::WireStatus::Ok, &data);
                if let Err(e) = stream.write_all(&response).await {
                    error!("Failed to write response: {}", e);
                }
            }
            Err(_) => {
                warn!("Shard not found: {}/{}/{}", content_id, chunk_index, shard_index);
                let response = datacraft_transfer::encode_response(datacraft_core::WireStatus::NotFound, b"");
                if let Err(e) = stream.write_all(&response).await {
                    error!("Failed to write not-found response: {}", e);
                }
            }
        }
    }
}