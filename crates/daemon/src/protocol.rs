//! DataCraft Protocol Handler
//!
//! Integrates DataCraft with libp2p swarm, handles DHT operations and incoming transfer streams.

use std::collections::HashMap;
use std::sync::Arc;

use datacraft_core::{ContentId, ChunkManifest, TransferReceipt, TRANSFER_PROTOCOL, SHARD_COORD_PROTOCOL};
use datacraft_core::signing::{sign_transfer_receipt, verify_transfer_receipt, peer_id_to_ed25519_pubkey};
use datacraft_routing::ContentRouter;
use datacraft_store::FsStore;
use datacraft_transfer::{decode_shard_request, REQUEST_HEADER_SIZE};
use craftec_network::{CraftBehaviour, behaviour::CraftBehaviourEvent};
use ed25519_dalek::{SigningKey, VerifyingKey};
use libp2p::kad;
use libp2p::swarm::SwarmEvent;
use libp2p_stream::IncomingStreams;
use tokio::sync::{mpsc, Mutex};
use tracing::{debug, error, info, warn};

use crate::receipt_store::PersistentReceiptStore;

/// Events generated by the DataCraft protocol handler.
#[derive(Debug)]
pub enum DataCraftEvent {
    /// DHT provider query completed.
    ProvidersResolved {
        content_id: ContentId,
        providers: Vec<libp2p::PeerId>,
    },
    /// DHT manifest record retrieved.
    ManifestRetrieved {
        content_id: ContentId,
        manifest: ChunkManifest,
    },
    /// DHT access list record retrieved.
    AccessListRetrieved {
        content_id: ContentId,
        access_list: datacraft_core::access::AccessList,
    },
    /// DHT operation failed.
    DhtError {
        content_id: ContentId,
        error: String,
    },
}

/// In-memory receipt store for TransferReceipts received from requesters.
#[derive(Debug, Default)]
pub struct ReceiptStore {
    receipts: Vec<TransferReceipt>,
}

impl ReceiptStore {
    pub fn new() -> Self {
        Self { receipts: Vec::new() }
    }

    /// Store a verified receipt.
    pub fn add(&mut self, receipt: TransferReceipt) {
        self.receipts.push(receipt);
    }

    /// Get all stored receipts.
    pub fn receipts(&self) -> &[TransferReceipt] {
        &self.receipts
    }

    /// Number of stored receipts.
    pub fn len(&self) -> usize {
        self.receipts.len()
    }

    /// Whether the store is empty.
    pub fn is_empty(&self) -> bool {
        self.receipts.is_empty()
    }
}

/// DataCraft protocol handler for registration on shared libp2p swarm.
pub struct DataCraftProtocol {
    /// Local content store.
    store: Arc<Mutex<FsStore>>,
    /// Event sender to the daemon.
    event_tx: mpsc::UnboundedSender<DataCraftEvent>,
    /// Pending DHT queries waiting for completion.
    pending_queries: Arc<Mutex<HashMap<kad::QueryId, PendingQuery>>>,
    /// In-memory receipt store (legacy, kept for protocol-level caching).
    receipt_store: Arc<Mutex<ReceiptStore>>,
    /// Persistent receipt store for durable receipt storage.
    persistent_receipt_store: Option<Arc<Mutex<PersistentReceiptStore>>>,
    /// Node's signing key for creating TransferReceipts when requesting shards.
    signing_key: Option<Arc<SigningKey>>,
    /// Shared removal cache — checked before serving shards.
    removal_cache: Option<Arc<Mutex<crate::removal_cache::RemovalCache>>>,
}

/// Tracks what we're waiting for from a DHT query.
#[derive(Debug)]
enum PendingQuery {
    ProvidersLookup { content_id: ContentId },
    ManifestLookup { content_id: ContentId },
    AccessListLookup { content_id: ContentId },
}

impl DataCraftProtocol {
    /// Create a new DataCraft protocol handler.
    pub fn new(
        store: Arc<Mutex<FsStore>>,
        event_tx: mpsc::UnboundedSender<DataCraftEvent>,
    ) -> Self {
        Self {
            store,
            event_tx,
            pending_queries: Arc::new(Mutex::new(HashMap::new())),
            receipt_store: Arc::new(Mutex::new(ReceiptStore::new())),
            persistent_receipt_store: None,
            signing_key: None,
            removal_cache: None,
        }
    }

    /// Set the persistent receipt store for durable storage.
    pub fn set_persistent_receipt_store(&mut self, store: Arc<Mutex<PersistentReceiptStore>>) {
        self.persistent_receipt_store = Some(store);
    }

    /// Set the removal cache for pre-serve checks.
    pub fn set_removal_cache(&mut self, cache: Arc<Mutex<crate::removal_cache::RemovalCache>>) {
        self.removal_cache = Some(cache);
    }

    /// Set the node's signing key for creating signed TransferReceipts.
    pub fn set_signing_key(&mut self, key: SigningKey) {
        self.signing_key = Some(Arc::new(key));
    }

    /// Access the receipt store.
    pub fn receipt_store(&self) -> &Arc<Mutex<ReceiptStore>> {
        &self.receipt_store
    }

    /// Register this protocol with the shared libp2p swarm.
    /// Returns (transfer_streams, shard_coord_streams).
    pub fn register(
        &self,
        swarm: &mut craftec_network::CraftSwarm,
    ) -> Result<(IncomingStreams, IncomingStreams), Box<dyn std::error::Error>> {
        debug!("Registering DataCraft transfer protocol: {}", TRANSFER_PROTOCOL);
        debug!("Registering DataCraft shard coordination protocol: {}", SHARD_COORD_PROTOCOL);
        
        // Get stream control from the behavior
        let mut control = swarm.behaviour().stream_control();
        
        // Accept incoming streams for our protocols
        let transfer_streams = control.accept(libp2p::StreamProtocol::new(TRANSFER_PROTOCOL))?;
        let coord_streams = control.accept(libp2p::StreamProtocol::new(SHARD_COORD_PROTOCOL))?;
        
        Ok((transfer_streams, coord_streams))
    }

    /// Announce this node as a provider for the given content ID.
    pub async fn announce_provider(
        &self,
        behaviour: &mut CraftBehaviour,
        content_id: &ContentId,
    ) -> Result<(), Box<dyn std::error::Error>> {
        debug!("Announcing as provider for {}", content_id);
        ContentRouter::announce(behaviour, content_id)?;
        Ok(())
    }

    /// Publish a manifest to the DHT.
    pub async fn publish_manifest(
        &self,
        behaviour: &mut CraftBehaviour,
        manifest: &ChunkManifest,
        local_peer_id: &libp2p::PeerId,
    ) -> Result<(), Box<dyn std::error::Error>> {
        debug!("Publishing manifest for {} to DHT", manifest.content_id);
        ContentRouter::publish_manifest(behaviour, manifest, local_peer_id)?;
        Ok(())
    }

    /// Resolve providers for a content ID via DHT.
    pub async fn resolve_providers(
        &self,
        behaviour: &mut CraftBehaviour,
        content_id: &ContentId,
    ) -> Result<(), Box<dyn std::error::Error>> {
        debug!("Resolving providers for {}", content_id);
        let query_id = ContentRouter::resolve(behaviour, content_id);
        
        // Track this query so we can match the response
        let mut queries = self.pending_queries.lock().await;
        queries.insert(query_id, PendingQuery::ProvidersLookup { 
            content_id: *content_id 
        });
        
        Ok(())
    }

    /// Get a manifest from the DHT.
    pub async fn get_manifest(
        &self,
        behaviour: &mut CraftBehaviour,
        content_id: &ContentId,
    ) -> Result<(), Box<dyn std::error::Error>> {
        debug!("Getting manifest for {}", content_id);
        let query_id = ContentRouter::get_manifest(behaviour, content_id);
        
        // Track this query
        let mut queries = self.pending_queries.lock().await;
        queries.insert(query_id, PendingQuery::ManifestLookup { 
            content_id: *content_id 
        });
        
        Ok(())
    }

    /// Get an access list from the DHT (tracked for async response).
    pub async fn get_access_list_dht(
        &self,
        behaviour: &mut CraftBehaviour,
        content_id: &ContentId,
    ) -> Result<(), Box<dyn std::error::Error>> {
        debug!("Getting access list for {} from DHT", content_id);
        let query_id = datacraft_routing::ContentRouter::get_access_list(behaviour, content_id);
        let mut queries = self.pending_queries.lock().await;
        queries.insert(query_id, PendingQuery::AccessListLookup {
            content_id: *content_id,
        });
        Ok(())
    }

    /// Handle libp2p swarm events related to DataCraft.
    pub async fn handle_swarm_event(&self, event: &SwarmEvent<CraftBehaviourEvent>) {
        match event {
            SwarmEvent::Behaviour(CraftBehaviourEvent::Kademlia(kad_event)) => {
                self.handle_kademlia_event(kad_event).await;
            }
            _ => {
                // Other events (connections, etc.) are handled by the main swarm loop
            }
        }
    }

    /// Handle Kademlia DHT events.
    async fn handle_kademlia_event(&self, event: &libp2p::kad::Event) {
        use libp2p::kad::Event;

        match event {
            Event::OutboundQueryProgressed { id, result, .. } => {
                self.handle_query_result(*id, result).await;
            }
            _ => {
                // Other Kademlia events not relevant for DataCraft
            }
        }
    }

    /// Handle the result of a DHT query.
    async fn handle_query_result(
        &self,
        query_id: kad::QueryId,
        result: &kad::QueryResult,
    ) {
        use libp2p::kad::{QueryResult, GetProvidersOk, GetRecordOk};

        let mut queries = self.pending_queries.lock().await;
        let pending = match queries.remove(&query_id) {
            Some(p) => p,
            None => {
                debug!("Received result for unknown query: {:?}", query_id);
                return;
            }
        };

        match (pending, result) {
            (PendingQuery::ProvidersLookup { content_id }, QueryResult::GetProviders(Ok(GetProvidersOk::FoundProviders { providers, .. }))) => {
                debug!("Found {} providers for {}", providers.len(), content_id);
                let provider_peers: Vec<libp2p::PeerId> = providers.iter().cloned().collect();
                
                let event = DataCraftEvent::ProvidersResolved {
                    content_id,
                    providers: provider_peers,
                };
                
                if let Err(e) = self.event_tx.send(event) {
                    error!("Failed to send providers resolved event: {}", e);
                }
            }
            
            (PendingQuery::ManifestLookup { content_id }, QueryResult::GetRecord(Ok(GetRecordOk::FoundRecord(peer_record)))) => {
                debug!("Found manifest record for {}", content_id);
                
                match datacraft_routing::parse_manifest_record(&peer_record.record.value) {
                    Ok(manifest) => {
                        let event = DataCraftEvent::ManifestRetrieved {
                            content_id,
                            manifest,
                        };
                        
                        if let Err(e) = self.event_tx.send(event) {
                            error!("Failed to send manifest retrieved event: {}", e);
                        }
                    }
                    Err(e) => {
                        warn!("Failed to parse manifest record for {}: {}", content_id, e);
                        let event = DataCraftEvent::DhtError {
                            content_id,
                            error: format!("Failed to parse manifest: {}", e),
                        };
                        
                        if let Err(e) = self.event_tx.send(event) {
                            error!("Failed to send DHT error event: {}", e);
                        }
                    }
                }
            }

            (PendingQuery::AccessListLookup { content_id }, QueryResult::GetRecord(Ok(GetRecordOk::FoundRecord(peer_record)))) => {
                debug!("Found access list record for {}", content_id);

                match datacraft_routing::parse_access_list_record(&peer_record.record.value) {
                    Ok(access_list) => {
                        let event = DataCraftEvent::AccessListRetrieved {
                            content_id,
                            access_list,
                        };
                        if let Err(e) = self.event_tx.send(event) {
                            error!("Failed to send access list retrieved event: {}", e);
                        }
                    }
                    Err(e) => {
                        warn!("Failed to parse access list record for {}: {}", content_id, e);
                        let event = DataCraftEvent::DhtError {
                            content_id,
                            error: format!("Failed to parse access list: {}", e),
                        };
                        if let Err(e) = self.event_tx.send(event) {
                            error!("Failed to send DHT error event: {}", e);
                        }
                    }
                }
            }

            (pending, result) => {
                debug!("Query {:?} completed with unhandled result: {:?}", pending, result);
                
                // Extract content_id for error reporting
                let content_id = match pending {
                    PendingQuery::ProvidersLookup { content_id } => content_id,
                    PendingQuery::ManifestLookup { content_id } => content_id,
                    PendingQuery::AccessListLookup { content_id } => content_id,
                };
                
                let error_msg = match result {
                    QueryResult::GetProviders(Err(e)) => format!("Providers lookup failed: {:?}", e),
                    QueryResult::GetRecord(Err(e)) => format!("Record lookup failed: {:?}", e),
                    _ => "Query completed with no results".to_string(),
                };
                
                let event = DataCraftEvent::DhtError {
                    content_id,
                    error: error_msg,
                };
                
                if let Err(e) = self.event_tx.send(event) {
                    error!("Failed to send DHT error event: {}", e);
                }
            }
        }
    }

    /// Request a shard from a remote peer.
    ///
    /// After receiving the shard successfully, creates and sends a TransferReceipt
    /// back to the server node.
    pub async fn request_shard_from_peer(
        &self,
        behaviour: &mut CraftBehaviour,
        peer_id: libp2p::PeerId,
        content_id: &ContentId,
        chunk_index: u32,
        shard_index: u8,
        local_public_key: &[u8; 32],
    ) -> Result<Vec<u8>, String> {
        use futures::{AsyncReadExt, AsyncWriteExt};
        use datacraft_transfer::{encode_shard_request, encode_receipt, RESPONSE_HEADER_SIZE};
        use datacraft_core::WireStatus;

        debug!(
            "Requesting shard {}/{}/{} from peer {}",
            content_id, chunk_index, shard_index, peer_id
        );

        // Get stream control from behavior
        let mut control = behaviour.stream_control();
        
        // Open stream to peer
        let mut stream = control
            .open_stream(peer_id, libp2p::StreamProtocol::new(TRANSFER_PROTOCOL))
            .await
            .map_err(|e| format!("Failed to open stream to {}: {}", peer_id, e))?;

        // Send request using the existing wire protocol
        let request = encode_shard_request(content_id, chunk_index, shard_index);
        stream.write_all(&request).await.map_err(|e| {
            format!("Failed to send request to {}: {}", peer_id, e)
        })?;

        // Read response header
        let mut header = [0u8; RESPONSE_HEADER_SIZE];
        stream.read_exact(&mut header).await.map_err(|e| {
            format!("Failed to read response header from {}: {}", peer_id, e)
        })?;

        let status = WireStatus::from_u8(header[0]).ok_or_else(|| {
            format!("Invalid status byte from {}: {}", peer_id, header[0])
        })?;
        let payload_len = u32::from_be_bytes([header[1], header[2], header[3], header[4]]) as usize;

        match status {
            WireStatus::Ok => {
                let mut payload = vec![0u8; payload_len];
                stream.read_exact(&mut payload).await.map_err(|e| {
                    format!("Failed to read payload from {}: {}", peer_id, e)
                })?;

                debug!(
                    "Successfully received shard {}/{}/{} ({} bytes) from peer {}",
                    content_id, chunk_index, shard_index, payload.len(), peer_id
                );

                // Create and send TransferReceipt back to the server
                let timestamp = std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .unwrap_or_default()
                    .as_secs();

                // Extract server's ed25519 public key from PeerId
                let server_node = peer_id_to_ed25519_pubkey(&peer_id)
                    .unwrap_or_else(|| {
                        // Fallback: use truncated PeerId bytes
                        let peer_bytes = peer_id.to_bytes();
                        let mut key = [0u8; 32];
                        let len = peer_bytes.len().min(32);
                        key[..len].copy_from_slice(&peer_bytes[..len]);
                        key
                    });

                let mut receipt = TransferReceipt {
                    content_id: *content_id,
                    server_node,
                    requester: *local_public_key,
                    shard_index: shard_index as u32,
                    bytes_served: payload.len() as u64,
                    timestamp,
                    signature: vec![],
                };

                // Sign the receipt with our signing key
                if let Some(ref signing_key) = self.signing_key {
                    sign_transfer_receipt(&mut receipt, signing_key);
                }

                // Send receipt — best effort, don't fail the transfer if receipt send fails
                match encode_receipt(&receipt) {
                    Ok(encoded) => {
                        if let Err(e) = stream.write_all(&encoded).await {
                            warn!("Failed to send receipt to {}: {}", peer_id, e);
                        } else {
                            debug!("Sent TransferReceipt to {} for {}/{}/{}", peer_id, content_id, chunk_index, shard_index);
                        }
                    }
                    Err(e) => {
                        warn!("Failed to encode receipt: {}", e);
                    }
                }

                Ok(payload)
            }
            WireStatus::NotFound => {
                Err(format!(
                    "Shard {}/{}/{} not found on peer {}",
                    content_id, chunk_index, shard_index, peer_id
                ))
            }
            WireStatus::Error => {
                let mut msg = vec![0u8; payload_len];
                stream.read_exact(&mut msg).await.ok();
                Err(format!(
                    "Error from peer {}: {}",
                    peer_id,
                    String::from_utf8_lossy(&msg)
                ))
            }
        }
    }

    /// Query a remote peer for their max shard index for a given CID.
    ///
    /// Protocol: `/datacraft/shard-coord/1.0.0`
    /// Request:  [content_id:32]
    /// Response: [status:1][max_index:1]  (status 0=found, 1=not_found)
    pub async fn query_max_shard_index(
        &self,
        behaviour: &mut CraftBehaviour,
        peer_id: libp2p::PeerId,
        content_id: &ContentId,
    ) -> Result<Option<u8>, String> {
        use futures::{AsyncReadExt, AsyncWriteExt};

        debug!("Querying peer {} for max shard index of {}", peer_id, content_id);

        let mut control = behaviour.stream_control();
        let mut stream = control
            .open_stream(peer_id, libp2p::StreamProtocol::new(SHARD_COORD_PROTOCOL))
            .await
            .map_err(|e| format!("Failed to open shard-coord stream to {}: {}", peer_id, e))?;

        // Send content_id
        stream.write_all(&content_id.0).await
            .map_err(|e| format!("Failed to send query to {}: {}", peer_id, e))?;

        // Read response: [status:1][max_index:1]
        let mut resp = [0u8; 2];
        stream.read_exact(&mut resp).await
            .map_err(|e| format!("Failed to read response from {}: {}", peer_id, e))?;

        match resp[0] {
            0 => Ok(Some(resp[1])),
            1 => Ok(None),
            _ => Err(format!("Invalid shard-coord status from {}: {}", peer_id, resp[0])),
        }
    }

    /// Handle an incoming shard coordination stream from a peer.
    pub async fn handle_incoming_coord_stream(&self, mut stream: libp2p::Stream) {
        use futures::{AsyncReadExt, AsyncWriteExt};

        // Read content_id
        let mut cid_bytes = [0u8; 32];
        if let Err(e) = stream.read_exact(&mut cid_bytes).await {
            error!("Failed to read shard-coord request: {}", e);
            return;
        }

        let content_id = ContentId(cid_bytes);
        let store = self.store.lock().await;

        let response = match store.max_shard_index_for_content(&content_id) {
            Some(max) => [0u8, max],       // status=found
            None => [1u8, 0u8],            // status=not_found
        };

        if let Err(e) = stream.write_all(&response).await {
            error!("Failed to write shard-coord response: {}", e);
        }

        debug!("Responded to shard-coord query for {}: {:?}", content_id, response);
    }

    /// Handle an incoming shard push from a peer.
    ///
    /// We already read REQUEST_HEADER_SIZE bytes; need to read the remaining push header
    /// bytes (payload_len:4) plus the payload itself, then store.
    async fn handle_incoming_push(&self, mut stream: libp2p::Stream, initial_header: &[u8]) {
        use futures::{AsyncReadExt, AsyncWriteExt};
        use datacraft_transfer::PUSH_HEADER_SIZE;

        // We've read REQUEST_HEADER_SIZE (42) bytes. Push header is PUSH_HEADER_SIZE (46).
        // Need 4 more bytes for payload_len.
        let mut extra = [0u8; 4];
        if let Err(e) = stream.read_exact(&mut extra).await {
            error!("Failed to read push header remainder: {}", e);
            return;
        }

        // Reconstruct full header
        let mut full_header = vec![0u8; PUSH_HEADER_SIZE];
        full_header[..REQUEST_HEADER_SIZE].copy_from_slice(initial_header);
        full_header[REQUEST_HEADER_SIZE..].copy_from_slice(&extra);

        let (content_id, chunk_index, shard_index, payload_len) =
            match datacraft_transfer::decode_shard_push_header(&full_header) {
                Ok(v) => v,
                Err(e) => {
                    error!("Failed to decode push header: {}", e);
                    let _ = stream.write_all(&[datacraft_core::WireStatus::Error as u8]).await;
                    return;
                }
            };

        // Sanity check payload size (max 16MB per shard)
        if payload_len > 16 * 1024 * 1024 {
            warn!("Push payload too large: {} bytes", payload_len);
            let _ = stream.write_all(&[datacraft_core::WireStatus::Error as u8]).await;
            return;
        }

        // Read payload
        let mut payload = vec![0u8; payload_len as usize];
        if let Err(e) = stream.read_exact(&mut payload).await {
            error!("Failed to read push payload: {}", e);
            let _ = stream.write_all(&[datacraft_core::WireStatus::Error as u8]).await;
            return;
        }

        // Check removal cache
        if let Some(ref cache) = self.removal_cache {
            let cache = cache.lock().await;
            if cache.is_removed(&content_id) {
                warn!("Refusing pushed shard for removed content: {}", content_id);
                let _ = stream.write_all(&[datacraft_core::WireStatus::Error as u8]).await;
                return;
            }
        }

        // Store the shard
        {
            let store = self.store.lock().await;
            match store.put_shard(&content_id, chunk_index, shard_index, &payload) {
                Ok(()) => {
                    info!(
                        "Stored pushed shard {}/{}/{} ({} bytes)",
                        content_id, chunk_index, shard_index, payload.len()
                    );
                    let _ = stream.write_all(&[datacraft_core::WireStatus::Ok as u8]).await;
                }
                Err(e) => {
                    error!("Failed to store pushed shard: {}", e);
                    let _ = stream.write_all(&[datacraft_core::WireStatus::Error as u8]).await;
                }
            }
        }
    }

    /// Push a shard to a remote peer for storage.
    ///
    /// Wire format: `[magic:4][type:1(ShardPush=5)][content_id:32][chunk_index:4][shard_index:1][payload_len:4][payload]`
    /// Response: `[status:1]` (0=Ok, 2=Error)
    pub async fn push_shard_to_peer(
        &self,
        behaviour: &mut CraftBehaviour,
        peer_id: libp2p::PeerId,
        content_id: &ContentId,
        chunk_index: u32,
        shard_index: u8,
        shard_data: &[u8],
    ) -> Result<(), String> {
        use futures::{AsyncReadExt, AsyncWriteExt};

        debug!(
            "Pushing shard {}/{}/{} ({} bytes) to peer {}",
            content_id, chunk_index, shard_index, shard_data.len(), peer_id
        );

        let mut control = behaviour.stream_control();
        let mut stream = control
            .open_stream(peer_id, libp2p::StreamProtocol::new(TRANSFER_PROTOCOL))
            .await
            .map_err(|e| format!("Failed to open stream to {}: {}", peer_id, e))?;

        // Send push message
        let msg = datacraft_transfer::encode_shard_push(content_id, chunk_index, shard_index, shard_data);
        stream.write_all(&msg).await.map_err(|e| {
            format!("Failed to send push to {}: {}", peer_id, e)
        })?;

        // Read single-byte status response
        let mut status = [0u8; 1];
        stream.read_exact(&mut status).await.map_err(|e| {
            format!("Failed to read push response from {}: {}", peer_id, e)
        })?;

        match datacraft_core::WireStatus::from_u8(status[0]) {
            Some(datacraft_core::WireStatus::Ok) => {
                debug!("Successfully pushed shard {}/{}/{} to {}", content_id, chunk_index, shard_index, peer_id);
                Ok(())
            }
            _ => Err(format!("Push rejected by peer {} with status {}", peer_id, status[0])),
        }
    }

    /// Handle an incoming transfer stream from a peer.
    ///
    /// After serving a shard successfully, reads a TransferReceipt from the
    /// requester, verifies it, and stores it for later settlement.
    pub async fn handle_incoming_stream(&self, mut stream: libp2p::Stream) {
        use futures::{AsyncReadExt, AsyncWriteExt};

        debug!("Handling incoming transfer stream");
        
        // Read the request header
        let mut header = [0u8; REQUEST_HEADER_SIZE];
        if let Err(e) = stream.read_exact(&mut header).await {
            error!("Failed to read request header: {}", e);
            return;
        }

        // Check if this is a ShardPush message (type byte at offset 4)
        if header[4] == datacraft_core::WireMessageType::ShardPush as u8 {
            self.handle_incoming_push(stream, &header).await;
            return;
        }

        // Decode the request
        let (content_id, chunk_index, shard_index) = match decode_shard_request(&header) {
            Ok(req) => req,
            Err(e) => {
                error!("Failed to decode shard request: {}", e);
                return;
            }
        };

        debug!(
            "Serving shard request: {} chunk={} shard={}",
            content_id, chunk_index, shard_index
        );

        // Pre-serve check: reject if content has been removed
        if let Some(ref cache) = self.removal_cache {
            let cache = cache.lock().await;
            if cache.is_removed(&content_id) {
                warn!("Refusing to serve removed content: {}", content_id);
                let response = datacraft_transfer::encode_response(datacraft_core::WireStatus::NotFound, b"");
                if let Err(e) = stream.write_all(&response).await {
                    error!("Failed to write removal-rejected response: {}", e);
                }
                return;
            }
        }

        // Serve the shard from local store
        let served_ok;
        let bytes_served;
        {
            let store = self.store.lock().await;
            match store.get_shard(&content_id, chunk_index, shard_index) {
                Ok(data) => {
                    debug!(
                        "Serving shard {}/{}/{} ({} bytes)",
                        content_id, chunk_index, shard_index, data.len()
                    );
                    bytes_served = data.len();
                    let response = datacraft_transfer::encode_response(datacraft_core::WireStatus::Ok, &data);
                    if let Err(e) = stream.write_all(&response).await {
                        error!("Failed to write response: {}", e);
                        return;
                    }
                    served_ok = true;
                }
                Err(_) => {
                    warn!("Shard not found: {}/{}/{}", content_id, chunk_index, shard_index);
                    bytes_served = 0;
                    let response = datacraft_transfer::encode_response(datacraft_core::WireStatus::NotFound, b"");
                    if let Err(e) = stream.write_all(&response).await {
                        error!("Failed to write not-found response: {}", e);
                    }
                    served_ok = false;
                }
            }
        }

        // After a successful shard serve, read the TransferReceipt from the requester
        if served_ok {
            // Read receipt header: magic(4) + type(1) + len(4) = 9 bytes
            let mut receipt_header = [0u8; 9];
            match stream.read_exact(&mut receipt_header).await {
                Ok(()) => {
                    if receipt_header[0..4] != datacraft_core::WIRE_MAGIC {
                        warn!("Invalid magic in receipt from requester");
                        return;
                    }
                    if receipt_header[4] != datacraft_core::WireMessageType::Receipt as u8 {
                        warn!("Expected Receipt message type, got {}", receipt_header[4]);
                        return;
                    }
                    let payload_len = u32::from_be_bytes([
                        receipt_header[5], receipt_header[6],
                        receipt_header[7], receipt_header[8],
                    ]) as usize;
                    let mut payload = vec![0u8; payload_len];
                    if let Err(e) = stream.read_exact(&mut payload).await {
                        warn!("Failed to read receipt payload: {}", e);
                        return;
                    }
                    match bincode::deserialize::<TransferReceipt>(&payload) {
                        Ok(receipt) => {
                            // Basic validation: content_id and shard_index should match
                            if receipt.content_id != content_id || receipt.shard_index != shard_index as u32 {
                                warn!("Receipt content/shard mismatch");
                                return;
                            }
                            if receipt.bytes_served != bytes_served as u64 {
                                warn!("Receipt bytes_served mismatch: got {} expected {}", receipt.bytes_served, bytes_served);
                                return;
                            }

                            // Verify receipt signature with requester's public key
                            if receipt.signature.len() == 64 {
                                if let Ok(pubkey) = VerifyingKey::from_bytes(&receipt.requester) {
                                    if !verify_transfer_receipt(&receipt, &pubkey) {
                                        warn!("TransferReceipt signature verification failed for {}/{}/{}", content_id, chunk_index, shard_index);
                                        return;
                                    }
                                    debug!("TransferReceipt signature verified for {}/{}/{}", content_id, chunk_index, shard_index);
                                } else {
                                    debug!("Could not parse requester pubkey for verification, accepting unsigned");
                                }
                            } else {
                                debug!("Receipt has no signature (unsigned), accepting for reputation tracking");
                            }

                            info!(
                                "Stored TransferReceipt for {}/{}/{} ({} bytes)",
                                content_id, chunk_index, shard_index, receipt.bytes_served
                            );

                            // Store in persistent receipt store if available
                            if let Some(ref persistent_store) = self.persistent_receipt_store {
                                let mut pstore = persistent_store.lock().await;
                                if let Err(e) = pstore.add_transfer(receipt.clone()) {
                                    warn!("Failed to persist receipt: {}", e);
                                }
                            }

                            // Also keep in in-memory store
                            let mut store = self.receipt_store.lock().await;
                            store.add(receipt);
                        }
                        Err(e) => {
                            warn!("Failed to deserialize receipt: {}", e);
                        }
                    }
                }
                Err(e) => {
                    // Requester may have disconnected without sending receipt — tolerate this
                    debug!("No receipt received from requester ({}), proceeding", e);
                }
            }
        }
    }
}