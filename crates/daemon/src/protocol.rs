//! DataCraft Protocol Handler
//!
//! Integrates DataCraft with libp2p swarm, handles DHT operations and incoming transfer streams.

use std::collections::HashMap;
use std::sync::Arc;

use datacraft_core::{ContentId, ContentManifest, TRANSFER_PROTOCOL};
use datacraft_routing::ContentRouter;
use datacraft_store::FsStore;
use datacraft_transfer::{
    decode_piece_request, decode_manifest_push_header,
    encode_piece_response, encode_piece_response_error,
    PIECE_REQUEST_SIZE, MANIFEST_PUSH_HEADER_SIZE,
};
use craftec_network::{CraftBehaviour, behaviour::CraftBehaviourEvent};
use libp2p::kad;
use libp2p::swarm::SwarmEvent;
use libp2p_stream::IncomingStreams;
use tokio::sync::{mpsc, Mutex};
use tracing::{debug, error, info, warn};

use crate::receipt_store::PersistentReceiptStore;
use crate::stream_manager::StreamPool;

/// Events generated by the DataCraft protocol handler.
#[derive(Debug)]
pub enum DataCraftEvent {
    /// DHT provider query completed.
    ProvidersResolved {
        content_id: ContentId,
        providers: Vec<libp2p::PeerId>,
    },
    /// DHT manifest record retrieved.
    ManifestRetrieved {
        content_id: ContentId,
        manifest: ContentManifest,
    },
    /// DHT access list record retrieved.
    AccessListRetrieved {
        content_id: ContentId,
        access_list: datacraft_core::access::AccessList,
    },
    /// DHT operation failed.
    DhtError {
        content_id: ContentId,
        error: String,
    },
    /// Manifest received via push from another node (we're storing for them).
    ManifestPushReceived {
        content_id: ContentId,
        manifest: ContentManifest,
    },
    /// Piece received via push — update local piece count in tracker.
    PiecePushReceived {
        content_id: ContentId,
    },
}

/// DataCraft protocol handler for registration on shared libp2p swarm.
pub struct DataCraftProtocol {
    /// Local content store.
    store: Arc<Mutex<FsStore>>,
    /// Event sender to the daemon.
    event_tx: mpsc::UnboundedSender<DataCraftEvent>,
    /// Pending DHT queries waiting for completion.
    pending_queries: Arc<Mutex<HashMap<kad::QueryId, PendingQuery>>>,
    /// Persistent receipt store for durable receipt storage.
    persistent_receipt_store: Option<Arc<Mutex<PersistentReceiptStore>>>,
    /// Shared removal cache — checked before serving pieces.
    removal_cache: Option<Arc<Mutex<crate::removal_cache::RemovalCache>>>,
    /// Demand tracker for scaling — records fetches when serving pieces.
    demand_tracker: Option<Arc<Mutex<crate::scaling::DemandTracker>>>,
    /// Eviction manager — records access for LRU tracking.
    eviction_manager: Option<Arc<Mutex<crate::eviction::EvictionManager>>>,
    /// Storage Merkle tree — updated on piece store/delete.
    merkle_tree: Option<Arc<Mutex<datacraft_store::merkle::StorageMerkleTree>>>,
    /// Stream pool for persistent outbound streams per peer.
    stream_pool: Option<Arc<Mutex<StreamPool>>>,
}

/// Tracks what we're waiting for from a DHT query.
#[derive(Debug)]
enum PendingQuery {
    ProvidersLookup { content_id: ContentId },
    ManifestLookup { content_id: ContentId },
    AccessListLookup { content_id: ContentId },
}

impl DataCraftProtocol {
    /// Create a new DataCraft protocol handler.
    pub fn new(
        store: Arc<Mutex<FsStore>>,
        event_tx: mpsc::UnboundedSender<DataCraftEvent>,
    ) -> Self {
        Self {
            store,
            event_tx,
            pending_queries: Arc::new(Mutex::new(HashMap::new())),
            persistent_receipt_store: None,
            removal_cache: None,
            demand_tracker: None,
            eviction_manager: None,
            merkle_tree: None,
            stream_pool: None,
        }
    }

    /// Set the persistent receipt store for durable storage.
    pub fn set_persistent_receipt_store(&mut self, store: Arc<Mutex<PersistentReceiptStore>>) {
        self.persistent_receipt_store = Some(store);
    }

    /// Set the removal cache for pre-serve checks.
    pub fn set_removal_cache(&mut self, cache: Arc<Mutex<crate::removal_cache::RemovalCache>>) {
        self.removal_cache = Some(cache);
    }

    pub fn set_demand_tracker(&mut self, tracker: Arc<Mutex<crate::scaling::DemandTracker>>) {
        self.demand_tracker = Some(tracker);
    }

    pub fn set_eviction_manager(&mut self, mgr: Arc<Mutex<crate::eviction::EvictionManager>>) {
        self.eviction_manager = Some(mgr);
    }

    pub fn set_merkle_tree(&mut self, tree: Arc<Mutex<datacraft_store::merkle::StorageMerkleTree>>) {
        self.merkle_tree = Some(tree);
    }

    pub fn set_stream_pool(&mut self, pool: Arc<Mutex<StreamPool>>) {
        self.stream_pool = Some(pool);
    }

    /// Register this protocol with the shared libp2p swarm.
    /// Returns incoming transfer streams.
    pub fn register(
        &self,
        swarm: &mut craftec_network::CraftSwarm,
    ) -> Result<IncomingStreams, Box<dyn std::error::Error>> {
        debug!("Registering DataCraft transfer protocol: {}", TRANSFER_PROTOCOL);

        let mut control = swarm.behaviour().stream_control();
        let transfer_streams = control.accept(libp2p::StreamProtocol::new(TRANSFER_PROTOCOL))?;

        Ok(transfer_streams)
    }

    /// Announce this node as a provider for the given content ID.
    pub async fn announce_provider(
        &self,
        behaviour: &mut CraftBehaviour,
        content_id: &ContentId,
    ) -> Result<(), Box<dyn std::error::Error>> {
        debug!("Announcing as provider for {}", content_id);
        ContentRouter::announce(behaviour, content_id)?;
        Ok(())
    }

    /// Publish a manifest to the DHT.
    pub async fn publish_manifest(
        &self,
        behaviour: &mut CraftBehaviour,
        manifest: &ContentManifest,
        local_peer_id: &libp2p::PeerId,
    ) -> Result<(), Box<dyn std::error::Error>> {
        debug!("Publishing manifest for {} to DHT", manifest.content_id);
        ContentRouter::publish_manifest(behaviour, manifest, local_peer_id)?;
        Ok(())
    }

    /// Resolve providers for a content ID via DHT.
    pub async fn resolve_providers(
        &self,
        behaviour: &mut CraftBehaviour,
        content_id: &ContentId,
    ) -> Result<(), Box<dyn std::error::Error>> {
        debug!("Resolving providers for {}", content_id);
        let query_id = ContentRouter::resolve(behaviour, content_id);

        let mut queries = self.pending_queries.lock().await;
        queries.insert(query_id, PendingQuery::ProvidersLookup {
            content_id: *content_id
        });

        Ok(())
    }

    /// Get a manifest from the DHT.
    pub async fn get_manifest(
        &self,
        behaviour: &mut CraftBehaviour,
        content_id: &ContentId,
    ) -> Result<(), Box<dyn std::error::Error>> {
        debug!("Getting manifest for {}", content_id);
        let query_id = ContentRouter::get_manifest(behaviour, content_id);

        let mut queries = self.pending_queries.lock().await;
        queries.insert(query_id, PendingQuery::ManifestLookup {
            content_id: *content_id
        });

        Ok(())
    }

    /// Get an access list from the DHT (tracked for async response).
    pub async fn get_access_list_dht(
        &self,
        behaviour: &mut CraftBehaviour,
        content_id: &ContentId,
    ) -> Result<(), Box<dyn std::error::Error>> {
        debug!("Getting access list for {} from DHT", content_id);
        let query_id = ContentRouter::get_access_list(behaviour, content_id);
        let mut queries = self.pending_queries.lock().await;
        queries.insert(query_id, PendingQuery::AccessListLookup {
            content_id: *content_id,
        });
        Ok(())
    }

    /// Handle libp2p swarm events related to DataCraft.
    pub async fn handle_swarm_event(&self, event: &SwarmEvent<CraftBehaviourEvent>) {
        match event {
            SwarmEvent::Behaviour(CraftBehaviourEvent::Kademlia(kad_event)) => {
                self.handle_kademlia_event(kad_event).await;
            }
            _ => {}
        }
    }

    /// Handle Kademlia DHT events.
    async fn handle_kademlia_event(&self, event: &libp2p::kad::Event) {
        use libp2p::kad::Event;

        match event {
            Event::OutboundQueryProgressed { id, result, .. } => {
                self.handle_query_result(*id, result).await;
            }
            _ => {}
        }
    }

    /// Handle the result of a DHT query.
    async fn handle_query_result(
        &self,
        query_id: kad::QueryId,
        result: &kad::QueryResult,
    ) {
        use libp2p::kad::{QueryResult, GetProvidersOk, GetRecordOk};

        let mut queries = self.pending_queries.lock().await;
        let pending = match queries.remove(&query_id) {
            Some(p) => p,
            None => {
                debug!("Received result for unknown query: {:?}", query_id);
                return;
            }
        };

        match (pending, result) {
            (PendingQuery::ProvidersLookup { content_id }, QueryResult::GetProviders(Ok(GetProvidersOk::FoundProviders { providers, .. }))) => {
                debug!("Found {} providers for {}", providers.len(), content_id);
                let provider_peers: Vec<libp2p::PeerId> = providers.iter().cloned().collect();

                let event = DataCraftEvent::ProvidersResolved {
                    content_id,
                    providers: provider_peers,
                };

                if let Err(e) = self.event_tx.send(event) {
                    error!("Failed to send providers resolved event: {}", e);
                }
            }

            (PendingQuery::ManifestLookup { content_id }, QueryResult::GetRecord(Ok(GetRecordOk::FoundRecord(peer_record)))) => {
                debug!("Found manifest record for {}", content_id);

                match datacraft_routing::parse_manifest_record(&peer_record.record.value) {
                    Ok(manifest) => {
                        let event = DataCraftEvent::ManifestRetrieved {
                            content_id,
                            manifest,
                        };

                        if let Err(e) = self.event_tx.send(event) {
                            error!("Failed to send manifest retrieved event: {}", e);
                        }
                    }
                    Err(e) => {
                        warn!("Failed to parse manifest record for {}: {}", content_id, e);
                        let event = DataCraftEvent::DhtError {
                            content_id,
                            error: format!("Failed to parse manifest: {}", e),
                        };

                        if let Err(e) = self.event_tx.send(event) {
                            error!("Failed to send DHT error event: {}", e);
                        }
                    }
                }
            }

            (PendingQuery::AccessListLookup { content_id }, QueryResult::GetRecord(Ok(GetRecordOk::FoundRecord(peer_record)))) => {
                debug!("Found access list record for {}", content_id);

                match datacraft_routing::parse_access_list_record(&peer_record.record.value) {
                    Ok(access_list) => {
                        let event = DataCraftEvent::AccessListRetrieved {
                            content_id,
                            access_list,
                        };
                        if let Err(e) = self.event_tx.send(event) {
                            error!("Failed to send access list retrieved event: {}", e);
                        }
                    }
                    Err(e) => {
                        warn!("Failed to parse access list record for {}: {}", content_id, e);
                        let event = DataCraftEvent::DhtError {
                            content_id,
                            error: format!("Failed to parse access list: {}", e),
                        };
                        if let Err(e) = self.event_tx.send(event) {
                            error!("Failed to send DHT error event: {}", e);
                        }
                    }
                }
            }

            (pending, result) => {
                debug!("Query {:?} completed with unhandled result: {:?}", pending, result);

                let content_id = match pending {
                    PendingQuery::ProvidersLookup { content_id } => content_id,
                    PendingQuery::ManifestLookup { content_id } => content_id,
                    PendingQuery::AccessListLookup { content_id } => content_id,
                };

                let error_msg = match result {
                    QueryResult::GetProviders(Err(e)) => format!("Providers lookup failed: {:?}", e),
                    QueryResult::GetRecord(Err(e)) => format!("Record lookup failed: {:?}", e),
                    _ => "Query completed with no results".to_string(),
                };

                let event = DataCraftEvent::DhtError {
                    content_id,
                    error: error_msg,
                };

                if let Err(e) = self.event_tx.send(event) {
                    error!("Failed to send DHT error event: {}", e);
                }
            }
        }
    }

    /// Request a piece from a remote peer.
    ///
    /// `piece_id` of all zeros means "any random piece for this segment".
    /// Returns (coefficients, data) on success.
    pub async fn request_piece_from_peer(
        &self,
        behaviour: &mut CraftBehaviour,
        peer_id: libp2p::PeerId,
        content_id: &ContentId,
        segment_index: u32,
        piece_id: &[u8; 32],
    ) -> Result<(Vec<u8>, Vec<u8>), String> {
        use futures::{AsyncReadExt, AsyncWriteExt};
        use datacraft_transfer::encode_piece_request;
        use datacraft_core::WireStatus;

        debug!(
            "Requesting piece {}/{} from peer {}",
            content_id, segment_index, peer_id
        );

        // Try stream pool first, fall back to fresh open_stream
        let (stream_arc, use_pool) = if let Some(ref pool) = self.stream_pool {
            let mut p = pool.lock().await;
            if let Some(s) = p.get_stream(&peer_id) {
                (Some(s), true)
            } else {
                p.ensure_opening(peer_id);
                (None, true)
            }
        } else {
            (None, false)
        };

        let result = if let Some(stream_arc) = stream_arc {
            let mut stream = stream_arc.lock().await;
            Self::do_request_piece(&mut *stream, peer_id, content_id, segment_index, piece_id).await
        } else if use_pool {
            // Pool is opening stream in background — fall back to direct open with timeout
            let mut control = behaviour.stream_control();
            let mut stream = tokio::time::timeout(
                std::time::Duration::from_secs(5),
                control.open_stream(peer_id, libp2p::StreamProtocol::new(TRANSFER_PROTOCOL)),
            )
            .await
            .map_err(|_| format!("Timed out opening stream to {}", peer_id))?
            .map_err(|e| format!("Failed to open stream to {}: {}", peer_id, e))?;
            Self::do_request_piece(&mut stream, peer_id, content_id, segment_index, piece_id).await
        } else {
            let mut control = behaviour.stream_control();
            let mut stream = control
                .open_stream(peer_id, libp2p::StreamProtocol::new(TRANSFER_PROTOCOL))
                .await
                .map_err(|e| format!("Failed to open stream to {}: {}", peer_id, e))?;
            Self::do_request_piece(&mut stream, peer_id, content_id, segment_index, piece_id).await
        };

        if result.is_err() {
            if let Some(ref pool) = self.stream_pool {
                pool.lock().await.mark_dead(&peer_id);
            }
        }
        result
    }

    /// Internal: perform piece request on an already-opened stream.
    async fn do_request_piece(
        stream: &mut libp2p::Stream,
        peer_id: libp2p::PeerId,
        content_id: &ContentId,
        segment_index: u32,
        piece_id: &[u8; 32],
    ) -> Result<(Vec<u8>, Vec<u8>), String> {
        use futures::{AsyncReadExt, AsyncWriteExt};
        use datacraft_transfer::encode_piece_request;
        use datacraft_core::WireStatus;

        let request = encode_piece_request(content_id, segment_index, piece_id);
        stream.write_all(&request).await.map_err(|e| {
            format!("Failed to send request to {}: {}", peer_id, e)
        })?;

        let mut status_byte = [0u8; 1];
        stream.read_exact(&mut status_byte).await.map_err(|e| {
            format!("Failed to read status from {}: {}", peer_id, e)
        })?;

        let status = WireStatus::from_u8(status_byte[0]).ok_or_else(|| {
            format!("Invalid status byte from {}: {}", peer_id, status_byte[0])
        })?;

        let mut len_buf = [0u8; 4];
        stream.read_exact(&mut len_buf).await.map_err(|e| {
            format!("Failed to read coeff_len from {}: {}", peer_id, e)
        })?;
        let coeff_len = u32::from_be_bytes(len_buf) as usize;

        match status {
            WireStatus::Ok => {
                let mut coefficients = vec![0u8; coeff_len];
                stream.read_exact(&mut coefficients).await.map_err(|e| {
                    format!("Failed to read coefficients from {}: {}", peer_id, e)
                })?;

                stream.read_exact(&mut len_buf).await.map_err(|e| {
                    format!("Failed to read data_len from {}: {}", peer_id, e)
                })?;
                let data_len = u32::from_be_bytes(len_buf) as usize;

                let mut data = vec![0u8; data_len];
                stream.read_exact(&mut data).await.map_err(|e| {
                    format!("Failed to read data from {}: {}", peer_id, e)
                })?;

                debug!(
                    "Received piece {}/{} ({} bytes data, {} bytes coeff) from {}",
                    content_id, segment_index, data.len(), coefficients.len(), peer_id
                );

                Ok((coefficients, data))
            }
            WireStatus::NotFound => {
                Err(format!(
                    "Piece {}/{} not found on peer {}",
                    content_id, segment_index, peer_id
                ))
            }
            WireStatus::Error => {
                Err(format!("Error from peer {}", peer_id))
            }
        }
    }

    /// Push a manifest to a remote peer.
    pub async fn push_manifest_to_peer(
        &self,
        behaviour: &mut CraftBehaviour,
        peer_id: libp2p::PeerId,
        content_id: &ContentId,
        manifest_json: &[u8],
    ) -> Result<(), String> {
        debug!("Pushing manifest for {} ({} bytes) to peer {}", content_id, manifest_json.len(), peer_id);

        let (stream_arc, use_pool) = if let Some(ref pool) = self.stream_pool {
            let mut p = pool.lock().await;
            if let Some(s) = p.get_stream(&peer_id) {
                (Some(s), true)
            } else {
                p.ensure_opening(peer_id);
                (None, true)
            }
        } else {
            (None, false)
        };

        let result = if let Some(stream_arc) = stream_arc {
            let mut stream = stream_arc.lock().await;
            Self::do_push_manifest(&mut *stream, peer_id, content_id, manifest_json).await
        } else if use_pool {
            let mut control = behaviour.stream_control();
            let mut stream = tokio::time::timeout(
                std::time::Duration::from_secs(5),
                control.open_stream(peer_id, libp2p::StreamProtocol::new(TRANSFER_PROTOCOL)),
            )
            .await
            .map_err(|_| format!("Timed out opening stream to {}", peer_id))?
            .map_err(|e| format!("Failed to open stream to {}: {}", peer_id, e))?;
            Self::do_push_manifest(&mut stream, peer_id, content_id, manifest_json).await
        } else {
            let mut control = behaviour.stream_control();
            let mut stream = control
                .open_stream(peer_id, libp2p::StreamProtocol::new(TRANSFER_PROTOCOL))
                .await
                .map_err(|e| format!("Failed to open stream to {}: {}", peer_id, e))?;
            Self::do_push_manifest(&mut stream, peer_id, content_id, manifest_json).await
        };

        if result.is_err() {
            if let Some(ref pool) = self.stream_pool {
                pool.lock().await.mark_dead(&peer_id);
            }
        }
        result
    }

    async fn do_push_manifest(
        stream: &mut libp2p::Stream,
        peer_id: libp2p::PeerId,
        content_id: &ContentId,
        manifest_json: &[u8],
    ) -> Result<(), String> {
        use futures::{AsyncReadExt, AsyncWriteExt};

        let msg = datacraft_transfer::encode_manifest_push(content_id, manifest_json);
        stream.write_all(&msg).await.map_err(|e| format!("Failed to send manifest push to {}: {}", peer_id, e))?;

        let mut status = [0u8; 1];
        stream.read_exact(&mut status).await.map_err(|e| format!("Failed to read manifest push response from {}: {}", peer_id, e))?;

        match datacraft_core::WireStatus::from_u8(status[0]) {
            Some(datacraft_core::WireStatus::Ok) => {
                debug!("Successfully pushed manifest for {} to {}", content_id, peer_id);
                Ok(())
            }
            _ => Err(format!("Manifest push rejected by peer {} with status {}", peer_id, status[0])),
        }
    }

    /// Push a piece to a remote peer for storage.
    pub async fn push_piece_to_peer(
        &self,
        behaviour: &mut CraftBehaviour,
        peer_id: libp2p::PeerId,
        content_id: &ContentId,
        segment_index: u32,
        piece_id: &[u8; 32],
        coefficients: &[u8],
        piece_data: &[u8],
    ) -> Result<(), String> {
        debug!(
            "Pushing piece {}/{}/{} ({} bytes) to peer {}",
            content_id, segment_index, &hex::encode(&piece_id[..4]), piece_data.len(), peer_id
        );

        let (stream_arc, use_pool) = if let Some(ref pool) = self.stream_pool {
            let mut p = pool.lock().await;
            if let Some(s) = p.get_stream(&peer_id) {
                (Some(s), true)
            } else {
                p.ensure_opening(peer_id);
                (None, true)
            }
        } else {
            (None, false)
        };

        let result = if let Some(stream_arc) = stream_arc {
            let mut stream = stream_arc.lock().await;
            Self::do_push_piece(&mut *stream, peer_id, content_id, segment_index, piece_id, coefficients, piece_data).await
        } else if use_pool {
            let mut control = behaviour.stream_control();
            let mut stream = tokio::time::timeout(
                std::time::Duration::from_secs(5),
                control.open_stream(peer_id, libp2p::StreamProtocol::new(TRANSFER_PROTOCOL)),
            )
            .await
            .map_err(|_| format!("Timed out opening stream to {}", peer_id))?
            .map_err(|e| format!("Failed to open stream to {}: {}", peer_id, e))?;
            Self::do_push_piece(&mut stream, peer_id, content_id, segment_index, piece_id, coefficients, piece_data).await
        } else {
            let mut control = behaviour.stream_control();
            let mut stream = control
                .open_stream(peer_id, libp2p::StreamProtocol::new(TRANSFER_PROTOCOL))
                .await
                .map_err(|e| format!("Failed to open stream to {}: {}", peer_id, e))?;
            Self::do_push_piece(&mut stream, peer_id, content_id, segment_index, piece_id, coefficients, piece_data).await
        };

        if result.is_err() {
            if let Some(ref pool) = self.stream_pool {
                pool.lock().await.mark_dead(&peer_id);
            }
        }
        result
    }

    async fn do_push_piece(
        stream: &mut libp2p::Stream,
        peer_id: libp2p::PeerId,
        content_id: &ContentId,
        segment_index: u32,
        piece_id: &[u8; 32],
        coefficients: &[u8],
        piece_data: &[u8],
    ) -> Result<(), String> {
        use futures::{AsyncReadExt, AsyncWriteExt};

        let msg = datacraft_transfer::encode_piece_push(content_id, segment_index, piece_id, coefficients, piece_data);
        stream.write_all(&msg).await.map_err(|e| {
            format!("Failed to send push to {}: {}", peer_id, e)
        })?;

        let mut status = [0u8; 1];
        stream.read_exact(&mut status).await.map_err(|e| {
            format!("Failed to read push response from {}: {}", peer_id, e)
        })?;

        match datacraft_core::WireStatus::from_u8(status[0]) {
            Some(datacraft_core::WireStatus::Ok) => {
                debug!("Successfully pushed piece {}/{} to {}", content_id, segment_index, peer_id);
                Ok(())
            }
            _ => Err(format!("Push rejected by peer {} with status {}", peer_id, status[0])),
        }
    }

    /// Handle an incoming transfer stream from a peer.
    ///
    /// Loops to handle multiple messages on the same persistent stream.
    /// Returns when the stream is closed (EOF) or an error occurs.
    pub async fn handle_incoming_stream(&self, mut stream: libp2p::Stream) {
        use futures::AsyncReadExt;

        debug!("Handling incoming transfer stream");

        loop {
            // Read enough bytes to determine message type.
            // All messages start with magic(4) + type(1).
            let mut type_header = [0u8; 5];
            match stream.read_exact(&mut type_header).await {
                Ok(_) => {}
                Err(e) if e.kind() == std::io::ErrorKind::UnexpectedEof => {
                    debug!("Incoming stream closed (EOF)");
                    return;
                }
                Err(e) => {
                    error!("Failed to read type header: {}", e);
                    return;
                }
            }

            if type_header[0..4] != datacraft_core::WIRE_MAGIC {
                error!("Invalid magic bytes");
                return;
            }

            let msg_type = type_header[4];

            if msg_type == datacraft_core::WireMessageType::ManifestPush as u8 {
                self.handle_incoming_manifest_push(&mut stream, &type_header).await;
                continue;
            }

            if msg_type == datacraft_core::WireMessageType::PiecePush as u8 {
                self.handle_incoming_piece_push(&mut stream, &type_header).await;
                continue;
            }

            if msg_type == datacraft_core::WireMessageType::PieceRequest as u8 {
                self.handle_incoming_piece_request(&mut stream, &type_header).await;
                continue;
            }

            if msg_type == datacraft_core::WireMessageType::InventoryRequest as u8 {
                self.handle_incoming_inventory_request(&mut stream, &type_header).await;
                continue;
            }

            error!("Unknown message type: {}", msg_type);
            return;
        }
    }

    /// Handle an incoming piece request.
    async fn handle_incoming_piece_request(&self, stream: &mut libp2p::Stream, type_header: &[u8; 5]) {
        use futures::{AsyncReadExt, AsyncWriteExt};

        // Read remaining bytes of piece request: content_id(32) + segment_index(4) + piece_id(32) = 68
        let mut rest = [0u8; 68];
        if let Err(e) = stream.read_exact(&mut rest).await {
            error!("Failed to read piece request body: {}", e);
            return;
        }

        // Reconstruct full header
        let mut full = [0u8; PIECE_REQUEST_SIZE];
        full[..5].copy_from_slice(type_header);
        full[5..].copy_from_slice(&rest);

        let (content_id, segment_index, piece_id) = match decode_piece_request(&full) {
            Ok(r) => r,
            Err(e) => {
                error!("Failed to decode piece request: {}", e);
                return;
            }
        };

        // Pre-serve check: reject if content has been removed
        if let Some(ref cache) = self.removal_cache {
            let cache = cache.lock().await;
            if cache.is_removed(&content_id) {
                warn!("Refusing to serve removed content: {}", content_id);
                let response = encode_piece_response_error(datacraft_core::WireStatus::NotFound);
                let _ = stream.write_all(&response).await;
                return;
            }
        }

        let store = self.store.lock().await;
        let is_any = piece_id == [0u8; 32];

        let result = if is_any {
            store.get_random_piece(&content_id, segment_index)
        } else {
            store
                .get_piece(&content_id, segment_index, &piece_id)
                .map(|(data, coeff)| Some((piece_id, data, coeff)))
        };

        match result {
            Ok(Some((_pid, data, coefficients))) => {
                debug!(
                    "Serving piece {}/{} ({} bytes data, {} bytes coeff)",
                    content_id, segment_index, data.len(), coefficients.len()
                );
                let response = encode_piece_response(datacraft_core::WireStatus::Ok, &coefficients, &data);
                if let Err(e) = stream.write_all(&response).await {
                    error!("Failed to write response: {}", e);
                }
                // Record fetch for demand tracking (scaling)
                if let Some(ref dt) = self.demand_tracker {
                    let mut tracker = dt.lock().await;
                    tracker.record_fetch(content_id);
                }
                // Record access for eviction LRU tracking
                if let Some(ref em) = self.eviction_manager {
                    let mut mgr = em.lock().await;
                    mgr.record_access(&content_id);
                }
            }
            _ => {
                warn!("Piece not found: {}/{}", content_id, segment_index);
                let response = encode_piece_response_error(datacraft_core::WireStatus::NotFound);
                let _ = stream.write_all(&response).await;
            }
        }
    }

    /// Handle an incoming piece push.
    async fn handle_incoming_piece_push(&self, stream: &mut libp2p::Stream, type_header: &[u8; 5]) {
        use futures::{AsyncReadExt, AsyncWriteExt};

        // PiecePush: [magic:4][type:1][content_id:32][segment_index:4][piece_id:32][coeff_len:4][coeff][data_len:4][data]
        // We already read 5 bytes. Read the rest of the fixed header: 32+4+32 = 68 more for fixed part
        let mut fixed_rest = [0u8; 68];
        if let Err(e) = stream.read_exact(&mut fixed_rest).await {
            error!("Failed to read piece push fixed header: {}", e);
            return;
        }

        // coeff_len(4)
        let mut coeff_len_buf = [0u8; 4];
        if let Err(e) = stream.read_exact(&mut coeff_len_buf).await {
            error!("Failed to read coeff_len: {}", e);
            return;
        }
        let coeff_len = u32::from_be_bytes(coeff_len_buf) as usize;

        let mut coefficients = vec![0u8; coeff_len];
        if coeff_len > 0 {
            if let Err(e) = stream.read_exact(&mut coefficients).await {
                error!("Failed to read coefficients: {}", e);
                return;
            }
        }

        // data_len(4)
        let mut data_len_buf = [0u8; 4];
        if let Err(e) = stream.read_exact(&mut data_len_buf).await {
            error!("Failed to read data_len: {}", e);
            return;
        }
        let data_len = u32::from_be_bytes(data_len_buf) as usize;

        if data_len > 16 * 1024 * 1024 {
            warn!("Push payload too large: {} bytes", data_len);
            let _ = stream.write_all(&[datacraft_core::WireStatus::Error as u8]).await;
            return;
        }

        let mut data = vec![0u8; data_len];
        if let Err(e) = stream.read_exact(&mut data).await {
            error!("Failed to read push data: {}", e);
            let _ = stream.write_all(&[datacraft_core::WireStatus::Error as u8]).await;
            return;
        }

        // Parse content_id, segment_index, piece_id from fixed_rest
        let mut cid_bytes = [0u8; 32];
        cid_bytes.copy_from_slice(&fixed_rest[0..32]);
        let content_id = ContentId(cid_bytes);
        let segment_index = u32::from_be_bytes([fixed_rest[32], fixed_rest[33], fixed_rest[34], fixed_rest[35]]);
        let mut piece_id = [0u8; 32];
        piece_id.copy_from_slice(&fixed_rest[36..68]);

        // Check removal cache
        if let Some(ref cache) = self.removal_cache {
            let cache = cache.lock().await;
            if cache.is_removed(&content_id) {
                warn!("Refusing pushed piece for removed content: {}", content_id);
                let _ = stream.write_all(&[datacraft_core::WireStatus::Error as u8]).await;
                return;
            }
        }

        // Store the piece
        {
            let store = self.store.lock().await;
            match store.store_piece(&content_id, segment_index, &piece_id, &data, &coefficients) {
                Ok(()) => {
                    info!(
                        "Stored pushed piece {}/{}/{} ({} bytes)",
                        content_id, segment_index, &hex::encode(&piece_id[..4]), data.len()
                    );
                    // Update storage Merkle tree
                    if let Some(ref mt) = self.merkle_tree {
                        mt.lock().await.insert(&content_id, segment_index, &piece_id);
                    }
                    let _ = self.event_tx.send(DataCraftEvent::PiecePushReceived { content_id });
                    let _ = stream.write_all(&[datacraft_core::WireStatus::Ok as u8]).await;
                }
                Err(e) => {
                    error!("Failed to store pushed piece: {}", e);
                    let _ = stream.write_all(&[datacraft_core::WireStatus::Error as u8]).await;
                }
            }
        }
    }

    /// Handle an incoming manifest push.
    async fn handle_incoming_manifest_push(&self, stream: &mut libp2p::Stream, type_header: &[u8; 5]) {
        use futures::{AsyncReadExt, AsyncWriteExt};

        // ManifestPush header: [magic:4][type:1][content_id:32][payload_len:4] = 41 bytes
        // We read 5. Need 36 more.
        let mut rest = [0u8; 36];
        if let Err(e) = stream.read_exact(&mut rest).await {
            error!("Failed to read manifest push header: {}", e);
            return;
        }

        let mut full_header = [0u8; MANIFEST_PUSH_HEADER_SIZE];
        full_header[..5].copy_from_slice(type_header);
        full_header[5..].copy_from_slice(&rest);

        let (content_id, payload_len) = match decode_manifest_push_header(&full_header) {
            Ok(v) => v,
            Err(e) => {
                error!("Failed to decode manifest push header: {}", e);
                let _ = stream.write_all(&[datacraft_core::WireStatus::Error as u8]).await;
                return;
            }
        };

        if payload_len > 10 * 1024 * 1024 {
            warn!("Manifest push payload too large: {} bytes", payload_len);
            let _ = stream.write_all(&[datacraft_core::WireStatus::Error as u8]).await;
            return;
        }

        let mut payload = vec![0u8; payload_len as usize];
        if let Err(e) = stream.read_exact(&mut payload).await {
            error!("Failed to read manifest push payload: {}", e);
            let _ = stream.write_all(&[datacraft_core::WireStatus::Error as u8]).await;
            return;
        }

        match serde_json::from_slice::<ContentManifest>(&payload) {
            Ok(manifest) => {
                let store = self.store.lock().await;
                match store.store_manifest(&manifest) {
                    Ok(()) => {
                        info!("Stored pushed manifest for {} ({} bytes)", content_id, payload_len);
                        let _ = self.event_tx.send(DataCraftEvent::ManifestPushReceived {
                            content_id,
                            manifest,
                        });
                        let _ = stream.write_all(&[datacraft_core::WireStatus::Ok as u8]).await;
                    }
                    Err(e) => {
                        error!("Failed to store pushed manifest: {}", e);
                        let _ = stream.write_all(&[datacraft_core::WireStatus::Error as u8]).await;
                    }
                }
            }
            Err(e) => {
                error!("Failed to parse pushed manifest for {}: {}", content_id, e);
                let _ = stream.write_all(&[datacraft_core::WireStatus::Error as u8]).await;
            }
        }
    }

    /// Handle an incoming inventory request.
    async fn handle_incoming_inventory_request(&self, stream: &mut libp2p::Stream, type_header: &[u8; 5]) {
        use futures::{AsyncReadExt, AsyncWriteExt};

        // InventoryRequest: [magic:4][type:1][content_id:32] — we already read 5, need 32 more
        let mut cid_bytes = [0u8; 32];
        if let Err(e) = stream.read_exact(&mut cid_bytes).await {
            error!("Failed to read inventory request body: {}", e);
            return;
        }
        let content_id = ContentId(cid_bytes);

        // Check removal cache
        if let Some(ref cache) = self.removal_cache {
            let cache = cache.lock().await;
            if cache.is_removed(&content_id) {
                let response = datacraft_transfer::encode_inventory_response_error(datacraft_core::WireStatus::NotFound);
                let _ = stream.write_all(&response).await;
                return;
            }
        }

        let store = self.store.lock().await;
        let manifest = match store.get_manifest(&content_id) {
            Ok(m) => m,
            Err(_) => {
                let response = datacraft_transfer::encode_inventory_response_error(datacraft_core::WireStatus::NotFound);
                let _ = stream.write_all(&response).await;
                return;
            }
        };

        let mut segments = Vec::new();
        for seg_idx in 0..manifest.segment_count as u32 {
            let piece_ids = match store.list_pieces(&content_id, seg_idx) {
                Ok(ids) => ids,
                Err(_) => continue,
            };
            let mut coefficient_vectors = Vec::new();
            for pid in &piece_ids {
                if let Ok((_data, coeff)) = store.get_piece(&content_id, seg_idx, pid) {
                    coefficient_vectors.push(coeff);
                }
            }
            if !coefficient_vectors.is_empty() {
                segments.push(datacraft_core::SegmentInventory {
                    segment_index: seg_idx,
                    coefficient_vectors,
                });
            }
        }

        let response = datacraft_core::InventoryResponse {
            content_id,
            segments,
        };
        let encoded = datacraft_transfer::encode_inventory_response(&response);
        if let Err(e) = stream.write_all(&encoded).await {
            error!("Failed to write inventory response: {}", e);
        }
    }

    /// Request inventory from a remote peer.
    pub async fn request_inventory_from_peer(
        &self,
        behaviour: &mut CraftBehaviour,
        peer_id: libp2p::PeerId,
        content_id: &ContentId,
    ) -> Result<datacraft_core::InventoryResponse, String> {
        debug!("Requesting inventory for {} from peer {}", content_id, peer_id);

        let (stream_arc, use_pool) = if let Some(ref pool) = self.stream_pool {
            let mut p = pool.lock().await;
            if let Some(s) = p.get_stream(&peer_id) {
                (Some(s), true)
            } else {
                p.ensure_opening(peer_id);
                (None, true)
            }
        } else {
            (None, false)
        };

        let result = if let Some(stream_arc) = stream_arc {
            let mut stream = stream_arc.lock().await;
            Self::do_request_inventory(&mut *stream, peer_id, content_id).await
        } else if use_pool {
            let mut control = behaviour.stream_control();
            let mut stream = tokio::time::timeout(
                std::time::Duration::from_secs(5),
                control.open_stream(peer_id, libp2p::StreamProtocol::new(datacraft_core::TRANSFER_PROTOCOL)),
            )
            .await
            .map_err(|_| format!("Timed out opening stream to {}", peer_id))?
            .map_err(|e| format!("Failed to open stream to {}: {}", peer_id, e))?;
            Self::do_request_inventory(&mut stream, peer_id, content_id).await
        } else {
            let mut control = behaviour.stream_control();
            let mut stream = control
                .open_stream(peer_id, libp2p::StreamProtocol::new(datacraft_core::TRANSFER_PROTOCOL))
                .await
                .map_err(|e| format!("Failed to open stream to {}: {}", peer_id, e))?;
            Self::do_request_inventory(&mut stream, peer_id, content_id).await
        };

        if result.is_err() {
            if let Some(ref pool) = self.stream_pool {
                pool.lock().await.mark_dead(&peer_id);
            }
        }
        result
    }

    async fn do_request_inventory(
        stream: &mut libp2p::Stream,
        peer_id: libp2p::PeerId,
        content_id: &ContentId,
    ) -> Result<datacraft_core::InventoryResponse, String> {
        use futures::{AsyncReadExt, AsyncWriteExt};

        let request = datacraft_transfer::encode_inventory_request(content_id);
        stream.write_all(&request).await.map_err(|e| {
            format!("Failed to send inventory request to {}: {}", peer_id, e)
        })?;

        let mut status_byte = [0u8; 1];
        stream.read_exact(&mut status_byte).await.map_err(|e| {
            format!("Failed to read inventory status from {}: {}", peer_id, e)
        })?;

        let status = datacraft_core::WireStatus::from_u8(status_byte[0]).ok_or_else(|| {
            format!("Invalid inventory status byte from {}: {}", peer_id, status_byte[0])
        })?;

        let mut len_buf = [0u8; 4];
        stream.read_exact(&mut len_buf).await.map_err(|e| {
            format!("Failed to read inventory payload_len from {}: {}", peer_id, e)
        })?;
        let payload_len = u32::from_be_bytes(len_buf) as usize;

        match status {
            datacraft_core::WireStatus::Ok => {
                let mut payload = vec![0u8; payload_len];
                stream.read_exact(&mut payload).await.map_err(|e| {
                    format!("Failed to read inventory payload from {}: {}", peer_id, e)
                })?;
                let response: datacraft_core::InventoryResponse = bincode::deserialize(&payload)
                    .map_err(|e| format!("Failed to deserialize inventory from {}: {}", peer_id, e))?;
                Ok(response)
            }
            datacraft_core::WireStatus::NotFound => {
                Err(format!("Inventory not found on peer {}", peer_id))
            }
            datacraft_core::WireStatus::Error => {
                Err(format!("Inventory error from peer {}", peer_id))
            }
        }
    }
}
