//! CraftObj Protocol Handler
//!
//! Handles DHT operations. Transfer is handled by request_response in service.rs.
//!
//! NOTE: DHT manifest records removed — piece headers are self-describing.
//! ContentManifest is auto-created from first received piece header.

use std::collections::HashMap;
use std::sync::Arc;

use craftobj_core::ContentId;
use craftobj_routing::ContentRouter;
use craftec_network::CraftBehaviour;
use libp2p::kad;
use libp2p::swarm::SwarmEvent;
use tokio::sync::{mpsc, Mutex};
use tracing::{debug, error};

/// Events generated by the CraftObj protocol handler.
#[derive(Debug)]
pub enum CraftObjEvent {
    /// DHT provider query completed.
    ProvidersResolved {
        content_id: ContentId,
        providers: Vec<libp2p::PeerId>,
    },
    /// DHT operation failed.
    DhtError {
        content_id: ContentId,
        error: String,
    },
    /// Piece received via push — update local piece count in tracker.
    PiecePushReceived {
        content_id: ContentId,
    },
    /// Manifest was auto-created from piece header fields (replaces ManifestPushReceived).
    /// Triggers: content tracking, eviction protection, challenger registration, DHT announce.
    ManifestAutoCreated {
        content_id: ContentId,
        manifest: craftobj_core::ContentManifest,
    },
}

/// CraftObj protocol handler — DHT operations only.
///
/// Transfer (piece request/push/inventory) is handled by
/// `libp2p_stream::Behaviour` + `StreamManager` in the swarm event loop.
pub struct CraftObjProtocol {
    /// Event sender to the daemon.
    pub(crate) event_tx: mpsc::UnboundedSender<CraftObjEvent>,
    /// Pending DHT queries waiting for completion.
    pending_queries: Arc<Mutex<HashMap<kad::QueryId, PendingQuery>>>,
}

/// Tracks what we're waiting for from a DHT query.
#[derive(Debug)]
enum PendingQuery {
    ProvidersLookup { content_id: ContentId },
}

impl CraftObjProtocol {
    /// Create a new CraftObj protocol handler.
    pub fn new(
        event_tx: mpsc::UnboundedSender<CraftObjEvent>,
    ) -> Self {
        Self {
            event_tx,
            pending_queries: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    /// Announce this node as a provider for the given content ID.
    pub async fn announce_provider(
        &self,
        behaviour: &mut CraftBehaviour,
        content_id: &ContentId,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        debug!("Announcing as provider for {}", content_id);
        ContentRouter::announce(behaviour, content_id)?;
        Ok(())
    }

    /// Resolve providers for a content ID via DHT.
    pub async fn resolve_providers(
        &self,
        behaviour: &mut CraftBehaviour,
        content_id: &ContentId,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        debug!("Resolving providers for {}", content_id);
        let query_id = ContentRouter::resolve(behaviour, content_id);

        let mut queries = self.pending_queries.lock().await;
        queries.insert(query_id, PendingQuery::ProvidersLookup {
            content_id: *content_id
        });

        Ok(())
    }

    // NOTE: publish_manifest / get_record removed — piece headers carry all
    // metadata. Local ContentManifest auto-created from first received piece.

    /// Handle libp2p swarm events related to CraftObj (DHT only).
    pub async fn handle_swarm_event<TBehaviourEvent>(&self, _event: &SwarmEvent<TBehaviourEvent>)
    where
        TBehaviourEvent: std::fmt::Debug,
    {
        // We only care about Kademlia events, which come through the craft behaviour.
        // Since we now use a wrapper behaviour, the caller extracts the craft events.
    }

    /// Handle a Kademlia event directly.
    pub async fn handle_kademlia_event(&self, event: &libp2p::kad::Event) {
        use libp2p::kad::Event;

        if let Event::OutboundQueryProgressed { id, result, .. } = event {
            self.handle_query_result(*id, result).await;
        }
    }

    /// Handle the result of a DHT query.
    async fn handle_query_result(
        &self,
        query_id: kad::QueryId,
        result: &kad::QueryResult,
    ) {
        use libp2p::kad::{QueryResult, GetProvidersOk};

        let mut queries = self.pending_queries.lock().await;
        let pending = match queries.remove(&query_id) {
            Some(p) => p,
            None => {
                debug!("Received result for unknown query: {:?}", query_id);
                return;
            }
        };

        match (pending, result) {
            (PendingQuery::ProvidersLookup { content_id }, QueryResult::GetProviders(Ok(GetProvidersOk::FoundProviders { providers, .. }))) => {
                debug!("Found {} providers for {}", providers.len(), content_id);
                let provider_peers: Vec<libp2p::PeerId> = providers.iter().cloned().collect();

                let event = CraftObjEvent::ProvidersResolved {
                    content_id,
                    providers: provider_peers,
                };

                if let Err(e) = self.event_tx.send(event) {
                    error!("Failed to send providers resolved event: {}", e);
                }
            }

            (pending, result) => {
                debug!("Query {:?} completed with unhandled result: {:?}", pending, result);

                let content_id = match pending {
                    PendingQuery::ProvidersLookup { content_id } => content_id,
                };

                let error_msg = match result {
                    QueryResult::GetProviders(Err(e)) => format!("Providers lookup failed: {:?}", e),
                    _ => "Query completed with no results".to_string(),
                };

                let event = CraftObjEvent::DhtError {
                    content_id,
                    error: error_msg,
                };

                if let Err(e) = self.event_tx.send(event) {
                    error!("Failed to send DHT error event: {}", e);
                }
            }
        }
    }
}
