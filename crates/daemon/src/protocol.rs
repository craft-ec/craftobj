//! DataCraft Protocol Handler
//!
//! Handles DHT operations. Transfer is handled by request_response in service.rs.

use std::collections::HashMap;
use std::sync::Arc;

use datacraft_core::{ContentId, ContentManifest};
use datacraft_routing::ContentRouter;
use craftec_network::CraftBehaviour;
use libp2p::kad;
use libp2p::swarm::SwarmEvent;
use tokio::sync::{mpsc, Mutex};
use tracing::{debug, error, warn};

/// Events generated by the DataCraft protocol handler.
#[derive(Debug)]
pub enum DataCraftEvent {
    /// DHT provider query completed.
    ProvidersResolved {
        content_id: ContentId,
        providers: Vec<libp2p::PeerId>,
    },
    /// DHT manifest record retrieved.
    ManifestRetrieved {
        content_id: ContentId,
        manifest: ContentManifest,
    },
    /// DHT access list record retrieved.
    AccessListRetrieved {
        content_id: ContentId,
        access_list: datacraft_core::access::AccessList,
    },
    /// DHT operation failed.
    DhtError {
        content_id: ContentId,
        error: String,
    },
    /// Manifest received via push from another node (we're storing for them).
    ManifestPushReceived {
        content_id: ContentId,
        manifest: ContentManifest,
    },
    /// Piece received via push — update local piece count in tracker.
    PiecePushReceived {
        content_id: ContentId,
    },
}

/// DataCraft protocol handler — DHT operations only.
///
/// Transfer (piece request/push/manifest push/inventory) is handled by
/// `libp2p_stream::Behaviour` + `StreamManager` in the swarm event loop.
pub struct DataCraftProtocol {
    /// Event sender to the daemon.
    pub(crate) event_tx: mpsc::UnboundedSender<DataCraftEvent>,
    /// Pending DHT queries waiting for completion.
    pending_queries: Arc<Mutex<HashMap<kad::QueryId, PendingQuery>>>,
}

/// Tracks what we're waiting for from a DHT query.
#[derive(Debug)]
enum PendingQuery {
    ProvidersLookup { content_id: ContentId },
    ManifestLookup { content_id: ContentId },
    AccessListLookup { content_id: ContentId },
}

impl DataCraftProtocol {
    /// Create a new DataCraft protocol handler.
    pub fn new(
        event_tx: mpsc::UnboundedSender<DataCraftEvent>,
    ) -> Self {
        Self {
            event_tx,
            pending_queries: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    /// Announce this node as a provider for the given content ID.
    pub async fn announce_provider(
        &self,
        behaviour: &mut CraftBehaviour,
        content_id: &ContentId,
    ) -> Result<(), Box<dyn std::error::Error>> {
        debug!("Announcing as provider for {}", content_id);
        ContentRouter::announce(behaviour, content_id)?;
        Ok(())
    }

    /// Publish a manifest to the DHT.
    pub async fn publish_manifest(
        &self,
        behaviour: &mut CraftBehaviour,
        manifest: &ContentManifest,
        local_peer_id: &libp2p::PeerId,
    ) -> Result<(), Box<dyn std::error::Error>> {
        debug!("Publishing manifest for {} to DHT", manifest.content_id);
        ContentRouter::publish_manifest(behaviour, manifest, local_peer_id)?;
        Ok(())
    }

    /// Resolve providers for a content ID via DHT.
    pub async fn resolve_providers(
        &self,
        behaviour: &mut CraftBehaviour,
        content_id: &ContentId,
    ) -> Result<(), Box<dyn std::error::Error>> {
        debug!("Resolving providers for {}", content_id);
        let query_id = ContentRouter::resolve(behaviour, content_id);

        let mut queries = self.pending_queries.lock().await;
        queries.insert(query_id, PendingQuery::ProvidersLookup {
            content_id: *content_id
        });

        Ok(())
    }

    /// Get a manifest from the DHT.
    pub async fn get_manifest(
        &self,
        behaviour: &mut CraftBehaviour,
        content_id: &ContentId,
    ) -> Result<(), Box<dyn std::error::Error>> {
        debug!("Getting manifest for {}", content_id);
        let query_id = ContentRouter::get_manifest(behaviour, content_id);

        let mut queries = self.pending_queries.lock().await;
        queries.insert(query_id, PendingQuery::ManifestLookup {
            content_id: *content_id
        });

        Ok(())
    }

    /// Get an access list from the DHT (tracked for async response).
    pub async fn get_access_list_dht(
        &self,
        behaviour: &mut CraftBehaviour,
        content_id: &ContentId,
    ) -> Result<(), Box<dyn std::error::Error>> {
        debug!("Getting access list for {} from DHT", content_id);
        let query_id = ContentRouter::get_access_list(behaviour, content_id);
        let mut queries = self.pending_queries.lock().await;
        queries.insert(query_id, PendingQuery::AccessListLookup {
            content_id: *content_id,
        });
        Ok(())
    }

    /// Handle libp2p swarm events related to DataCraft (DHT only).
    pub async fn handle_swarm_event<TBehaviourEvent>(&self, _event: &SwarmEvent<TBehaviourEvent>)
    where
        TBehaviourEvent: std::fmt::Debug,
    {
        // We only care about Kademlia events, which come through the craft behaviour.
        // Since we now use a wrapper behaviour, the caller extracts the craft events.
    }

    /// Handle a Kademlia event directly.
    pub async fn handle_kademlia_event(&self, event: &libp2p::kad::Event) {
        use libp2p::kad::Event;

        match event {
            Event::OutboundQueryProgressed { id, result, .. } => {
                self.handle_query_result(*id, result).await;
            }
            _ => {}
        }
    }

    /// Handle the result of a DHT query.
    async fn handle_query_result(
        &self,
        query_id: kad::QueryId,
        result: &kad::QueryResult,
    ) {
        use libp2p::kad::{QueryResult, GetProvidersOk, GetRecordOk};

        let mut queries = self.pending_queries.lock().await;
        let pending = match queries.remove(&query_id) {
            Some(p) => p,
            None => {
                debug!("Received result for unknown query: {:?}", query_id);
                return;
            }
        };

        match (pending, result) {
            (PendingQuery::ProvidersLookup { content_id }, QueryResult::GetProviders(Ok(GetProvidersOk::FoundProviders { providers, .. }))) => {
                debug!("Found {} providers for {}", providers.len(), content_id);
                let provider_peers: Vec<libp2p::PeerId> = providers.iter().cloned().collect();

                let event = DataCraftEvent::ProvidersResolved {
                    content_id,
                    providers: provider_peers,
                };

                if let Err(e) = self.event_tx.send(event) {
                    error!("Failed to send providers resolved event: {}", e);
                }
            }

            (PendingQuery::ManifestLookup { content_id }, QueryResult::GetRecord(Ok(GetRecordOk::FoundRecord(peer_record)))) => {
                debug!("Found manifest record for {}", content_id);

                match datacraft_routing::parse_manifest_record(&peer_record.record.value) {
                    Ok(manifest) => {
                        let event = DataCraftEvent::ManifestRetrieved {
                            content_id,
                            manifest,
                        };

                        if let Err(e) = self.event_tx.send(event) {
                            error!("Failed to send manifest retrieved event: {}", e);
                        }
                    }
                    Err(e) => {
                        warn!("Failed to parse manifest record for {}: {}", content_id, e);
                        let event = DataCraftEvent::DhtError {
                            content_id,
                            error: format!("Failed to parse manifest: {}", e),
                        };

                        if let Err(e) = self.event_tx.send(event) {
                            error!("Failed to send DHT error event: {}", e);
                        }
                    }
                }
            }

            (PendingQuery::AccessListLookup { content_id }, QueryResult::GetRecord(Ok(GetRecordOk::FoundRecord(peer_record)))) => {
                debug!("Found access list record for {}", content_id);

                match datacraft_routing::parse_access_list_record(&peer_record.record.value) {
                    Ok(access_list) => {
                        let event = DataCraftEvent::AccessListRetrieved {
                            content_id,
                            access_list,
                        };
                        if let Err(e) = self.event_tx.send(event) {
                            error!("Failed to send access list retrieved event: {}", e);
                        }
                    }
                    Err(e) => {
                        warn!("Failed to parse access list record for {}: {}", content_id, e);
                        let event = DataCraftEvent::DhtError {
                            content_id,
                            error: format!("Failed to parse access list: {}", e),
                        };
                        if let Err(e) = self.event_tx.send(event) {
                            error!("Failed to send DHT error event: {}", e);
                        }
                    }
                }
            }

            (pending, result) => {
                debug!("Query {:?} completed with unhandled result: {:?}", pending, result);

                let content_id = match pending {
                    PendingQuery::ProvidersLookup { content_id } => content_id,
                    PendingQuery::ManifestLookup { content_id } => content_id,
                    PendingQuery::AccessListLookup { content_id } => content_id,
                };

                let error_msg = match result {
                    QueryResult::GetProviders(Err(e)) => format!("Providers lookup failed: {:?}", e),
                    QueryResult::GetRecord(Err(e)) => format!("Record lookup failed: {:?}", e),
                    _ => "Query completed with no results".to_string(),
                };

                let event = DataCraftEvent::DhtError {
                    content_id,
                    error: error_msg,
                };

                if let Err(e) = self.event_tx.send(event) {
                    error!("Failed to send DHT error event: {}", e);
                }
            }
        }
    }
}
